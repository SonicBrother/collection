# GC四大算法详解

## 0. 如何判断Java中对象是否存活？

### 0.1 引用计数算法

**引用计数算法**是给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器+1，当引用失效的时候，计数器-1，当计数器为0的时候，JVM就认为该对象不再被使用，是“垃圾”了。

引用计数**实现简单，效率高**；但是不能解决**循环引用**问问题（A对象引用B对象，B对象又引用A对象，但是A，B对象已不被任何其他对象引用），同时**每次计数器的增加和减少都带来了很多额外的开销**，所以在JDK1.1之后，这个算法已经不再使用了。
![引用计数](https://img-blog.csdnimg.cn/20200807170516550.png#pic_center)

### 0.2 根搜索方法

**根搜索方法**是通过一些`GCRoots`对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链（ReferenceChain），当一个对象没有被`GCRoots`的引用链连接的时候，说明这个对象是不可用的。

**GCRoots对象包括：**

1. 虚拟机栈（栈帧中的本地变量表）中的引用的对象。
2. 方法区域中的类静态属性引用的对象。
3. 方法区域中常量引用的对象。
4. 方法栈中JNI（`Native`方法）的引用的对象。
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200807180534899.png)

## 1. 复制算法（Copying）：适用于新生代

### 1.1 原理分析

虚拟机把新生代分为了三部分：1个`Eden`区和2个`Survivor`区（分别叫`from`和`to`），默认比例为8:1:1。

~~~
新生代和养老代的内存比例为1：2
~~~

一般情况下，新创建的对象都会被分配到`Eden`区（一些大对象特殊处理），这些对象经过第一次`Minor GC`后，如果仍然存活，将会被移到`Survivor`区。对象在`Survivor`区中每熬过一次`Minor GC`，年龄 +1，当它的年龄增加到一定程度时（默认是 15 ，通过`-XX:MaxTenuringThreshold`来设定参数），就会被移动到年老代中。

因为新生代中的对象基本都是**朝生夕死**（被GC回收率98%以上），**所以在新生代的垃圾回收算法使用的是复制算法**。

复制算法的基本思想就是将内存分为两块，每次只用其中一块（`from`），当这一块内存用完，就将还活着的对象复制到另外一块上面。

我们来举个栗子，在GC开始的时候，对象只会存在于`Eden`区和名为`from`的`Survivor`区，`Survivor`区`to`是空的。紧接着进行GC，`Eden`区中所有存活的对象都会被复制到`to`，而在`from`区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值（默认15）的对象会被移动到老年代中，没有达到阈值的对象会被复制到`to`区域。经过这次GC后，`Eden`区和`from`区已经被清空。这个时候，`from`和`to`会交换他们的角色，也就是新的`to`就是上次GC前的`from`，新的`from`就是上次GC前的`to`。不管怎样，都会保证名为`to`的`Survivor`区域是空的。`Minor GC`会一直重复这样的过程，直到`to`区被填满，`to`区被填满之后，会将所有对象移动到老年代中。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200807183357142.png#pic_center)

> `-XX:MaxTenuringThreshold`，设置对象在新生代中存活的次数。

因为`Eden`区对象一般存活率较低，一般的，使用两块10%的内存作为空闲和活动区间，而另外80%的内存，则是用来给新建对象分配内存的。一旦发生GC，将10%的`from`活动区间与另外80%中存活的`Eden`区对象转移到10%的`to`空闲区间，接下来，将之前90%的内存全部释放，以此类推。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200807160818909.gif#pic_center)
上面动画中，Area空闲代表to，Area激活代表from，绿色代表不被回收的，红色代表被回收的。

### 1.2 优缺点

**优点** ：不会产生内存碎片，效率高。

**缺点** ：耗费内存空间。

**前提**：eden 区的对象存活率很低。

如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。

所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。

## 2. 标记清除（Mark-Sweep）：适用于老年代

### 2.1 原理分析

标记清除算法，主要分成标记和清除两个阶段，先标记出要回收的对象，然后统一回收这些对象，如下图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200807184746659.png#pic_center)
简单来说，标记清除算法就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将要回收的对象标记一遍，最终统一回收这些对象，完成标记清理工作接下来便让应用程序恢复运行。

主要进行两项工作，第一项则是标记，第二项则是清除。

- 标记：从引用根节点开始标记遍历所有的`GC Roots`， 先标记出要回收的对象。
- 清除：遍历整个堆，把标记的对象清除。
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200807160938544.gif#pic_center)

### 2.2 优缺点

**优点** ：不需要额外的内存空间。
**缺点** ：需要暂停整个应用，会产生内存碎片；两次扫描，耗时严重。

简单来说，它的缺点就是**效率比较低**（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲。

而且这种方式**清理出来的空闲内存是不连续**的，这点不难理解，我们的死亡对象都是随机分布在内存当中，现在把它们清除之后，内存的布局自然会零碎不连续。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。并且在分配数组对象的时候，需要去内存寻找连续的内存空间，但此时的内存空间太过零碎分散，因此资源耗费加大。

## 3. 标记压缩（Mark-Compact）：适用于老年代

### 3.1 原理分析

简单来说，就是**先标记，后整理**，如下图所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200807185820542.png#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200807161246378.gif#pic_center)

### 3.2 优缺点

**优点** ：没有内存碎片。
**缺点** ：需要移动对象的成本，效率也不高（不仅要标记所有存活对象，还要整理所有存活对象的引用地址）。

### 3.3 标记清除压缩（Mark-Sweep-Compact）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200807190452284.png#pic_center)

## 4. 分代收集算法

当前商业虚拟机都是采用分代收集算法，它根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，然后根据各个年代的特点采用最适当的垃圾收集算法。

~~~markdown
在`新生代`中，每次垃圾收集都发现有大批对象死去，只有少量存活，就选用**复制算法**；

而`老年代`因为对象存活率高，没有额外空间对它进行分配担保，就必须使用**标记清除**或者**标记压缩**算法来进行回收；

在`元空间`中基本不存在垃圾回收。
~~~

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200807161123464.png#pic_center)

## 5. 总结

### 5.1 年轻代（Young Gen）

**年轻代特点是内存空间相对老年代较小，对象存活率低。**

复制算法的效率只和当前存活对象大小有关，因而很适用于年轻代的回收。而复制算法的内存利用率不高的问题，可以通过虚拟机中的两个`Survivor`区设计得到缓解。

### 5.2 老年代（Tenure Gen）

**老年代的特点是内存空间较大，对象存活率高。**

这种情况，存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记清除或者是标记清除与标记整理的混合实现。

（1）**标记阶段（Mark）** 的开销与存活对象的数量成正比。这点上说来，对于老年代，标记清除或者标记整理有一些不符，但可以通过多核/线程利用，对并发、并行的形式提标记效率。
（2）**清除阶段（Sweep）** 的开销与所管理内存空间大小形正相关。但Sweep“就地处决”的特点，回收的过程没有对象的移动。使其相对其他有对象移动步骤的回收算法，仍然是效率最好的。但是需要解决内存碎片问题。
（3）**整理阶段（Compact）** 的开销与存活对象的数据成开比。如上一条所描述，对于大量对象的移动是很大开销的，做为老年代的第一选择并不合适。

基于上面的考虑，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。以虚拟机中的CMS回收器为例，CMS是基于`Mark-Sweep`实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于`Mark-Compact`算法的Serial Old回收器做为补偿措施：当内存回收不佳（碎片导致的`Concurrent Mode Failure`时），将采用Serial Old执行Full GC以达到对老年代内存的整理。

---

## 6. gc

在程序中手动输入`System.gc()`，垃圾回收不会立即执行，会有jvm决定执行时机。（可以另外增加sleep指令强行让jvm进行垃圾回收。）现在的jvm垃圾回收机制已经非常完善，不需要手动调用，因此最好禁用`手动显示调用gc`



FGC比YGC速度慢：

1. 养老区本身范围就比YGC大
2. 